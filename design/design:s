

#############################################
######### SIMPLE FACTORIAL FUNCTION #########
#############################################

#*

Go-Like inspired type following, a function per default consists
of:
- The function keyword "fn"
- The function identifier = a variable name.
- The function parameters in round brackets: (parameter name and
  its' type)
- The return type
- The function body.

ret = return
*#

fn factorial (n uint) int {
   if n <= 1
      ret 1
   # elif
      ret factorial(n - 1) * n
}

#####################################
######### PRINTING, METHODS #########
#####################################

#*

A form of functions provided by ScriptPL are methods. These do
not require round brackets and get a keyword highlight. Unlike
functions, that cannot return a value, they are just a set of
other methods.
Below is how content is printed to the console/ output.

Methods consist of the following structure:

            \/ No comma here
METHOD_TYPE   PARAM1, PARAM2, ...

*#

out: factorial(5)

# Create a method consuming any amount of parameters.
# Output all parameters into the "out"-method, in addition the
# 0A-byte: newline character.
# This is how to create a method to output a newline and content
fn outln (params [... _]) {
   out: params, b0A
}

fn with_parameters (i int, j int, k int) {
   # Do something
}

fn without_parameters () {
   # Do something
}

outln: 'Hello, World!'
with_parameters: 5, 5, 5
without_parameters:

#######################################
######### FIBONACCI GENERATOR #########
#######################################

# This function will run indefinitely.
fn fibonacci () []uint {
   be f = (0, 1)

   for {
      f += f(f.l - 1) + f(f.l) # push to f: sum of last two values
   }

   ret f
}

array.l # returns array length
array.len # too

# Behind them are getters. Functions that are called without brackets.
# More about structure-methods/ functions/ getters later.

# Here's an exmple how to force the end of a function

be x = fibonacci()  # Start a fibonacci collector
sleep: 1000          # Sleep main thread for 1000 milliseconds
x.leave:             # End x's function thread. This is a method on a
                     # type. More about them, later.
out: x               # [0, 1, 1, 2, 3, 5, 8, 13, 21, ... ]

##################################################
######### INLINE FUNCTIONS - MATH SYNTAX #########
##################################################

fn f (x) {
   ret 2 * x + 5
}

out: f(2)

# the function is is the same as

fn f (x) -> {
   ret 2 * x + 5
}

# is the same as

fn f (x) -> 2 * x + 5

###########################
######### IMPORTS #########
###########################

use (
   'time'                              # Import 'time' library
   'pkg:github.com/Something/proj'     # Import as 'proj'
   '/path/to/file.sc'                  # Import from source
   './path/to/file.sc'                 # Import 'file' from current directory
   '../path/to/file.sc'                # Import 'file' from parent directory
)

# special

use *strict        # strict could forbid declaration of operations, some meta programming, etc.
use (*unsafe *asm) # unsafe could support an 'eval' method to execute string as code
                   # asm could allow direct assembly commands

# "strict" forces strict programming:
#   - no further meta programming
#   - no assembly coding (?)
# "unsafe" could open declarations of variables to outside of code
#   - 'eval' method to JIT-compile strings into the language
# "asm": assembly input
#   - assembly coding in code

###########################################
######### ENTITY COMPONENT SYSTEM #########
###########################################

type EmptyTag # Simple Type

type Position <
   x int
   y int
>

type Velocity <
   x int, y int
>

type Asset <
   image Image
>

be predefinedComp = Velocity (
   x = 5
   y = 5
)

be hero int = new (
   EmptyTag
   Position (
      x = 0
      y = 0
   )
   predefinedComp
   Asset (
      image = Image ()
   )
)

hero.del:

#
# Iterate over component-combinations
#

for eid int in query (Position, Velocity) {
   Position(eid).x += Velocity(eid).x
   Position(eid).y += Velocity(eid).y
}

for eid int in query (Position, Asset) {
   Asset(eid).image.render(Position(eid).x, Position(eid).y)
}

# In case for loop is not nested and
# entity id is not required. Shortcut:

for query (Position, Velocity) {
   Position.x += Velocity.x
   Position.y += Velocity.y
}

for query (Position, Asset) {
   Asset.image.render(Position.x, Position.y)
}

##########
# Vector #
##########

struct Vector (int * 3)

v1 <Vector> = (1, 2, 3)
v2 <Vector> = (4, 5, 6)

Vector {
   $["sum"]
   fn (self, Vector) {

   }
}

out: v1 + v2 # Vector (5, 7, 9)

############################
######### ASSEMBLY #########
############################

use (*asm)

#
# (f - full, optional), h - half, q - quarter
#

rA-f  # First FULL Register     1111 (4 bytes)
rB-h  # Second HALF Register    0011 (2 bytes)
rC-q  # Third QUARTER Register  0001 (1 byte)
rD    # Fourth Register (full by default)

#
# Assembly Flags
#

fO # Overflow Flag:        High-order bit overflow after arithmetic operation
fD # Direction Flag:
fI # Interrupt Flag:
fT # Trap Flag:
fS # Sign Flag:            Sign of result of arithmetic operation
fZ # Zero Flag:            Result of arihtmetic operation is zero
fA # Auxiliary Carry Flag: 
fP # Parity Flag:          Amount of zeros after arithmetic operation
fC # Carry Flag:           Overflow/ Carry:   1010 + 1011 = 1, 0101

#
# OTHER LANGUAGES BUILT IN
#

# JavaScript Built-In
js (
   function k {
      let k = 'Hello, World!'
      console.log(k)
   }
)

# Lua Built-In (or not)
#*lua (
   function k ()
      local k = "Hello, World!"
      print (k)
   end
)*#

# Html Built-In
</
   <tag attribute="value">
      <b>Hello, {{
         "World!"
      }}!</b>
   </tag>
/>

fn getHtml() {
   ret </<b>Hello, World!</b>/>
}

# Assembly Writing
asm (
   mov %eax, %edx
   add %eax, 2
)
