

#############################################
######### SIMPLE FACTORIAL FUNCTION #########
#############################################

#*

Go-Like inspired type following, a function per default consists
of:
- The function keyword "fn"
- The function identifier = a variable name.
- The function parameters in round brackets: (parameter name and
  its' type)
- The return type
- The function body.

Functions will have two ways of sending output. One of them is
the "exit" keyword, which acts as regular "return" in most
languages.

The "if" keyword usually requires a code body, but it is not
needed if followed by 'methods', in this case, the exit-method.
Example of if block which is followed by setting:
if x == 5 do x := 4

*#

fn factorial (n uint) int {
   if n <= 1
      exit 1
   # elif
      exit factorial(n - 1) * n
}

#####################################
######### PRINTING, METHODS #########
#####################################

#*

A form of functions provided by ScriptPL are methods. These do
not require round brackets and get a keyword highlight. Unlike
functions, that cannot return a value, they are just a set of
other methods.
Below is how content is printed to the console/ output.

Methods consist of the following structure:

            \/ No comma here
METHOD_TYPE   PARAM1, PARAM2, ...

*#

out: factorial(5)

# Create a method consuming any amount of parameters.
# Output all parameters into the "out"-method, in addition the
# 0A-byte: newline character.
# This is how to create a method to output a newline and content
fn outln ([...] params any) {
   out: params, b0A
}

fn with_parameters (i int, j int, k int) {
   # Do something
}

fn without_parameters () {
   # Do something
}

outln: 'Hello, World!'
with_parameters: 5, 5, 5
without_parameters:

##################################
######### RETURN vs EXIT #########
##################################

#*

As mentioned previously, to quit function, you write "exit".
Alternatively you can "return" a value and keep the function
running in a separate thread.

The function below returns a referenced variable (declaration)
"prime_list", that is an array containing the numbers 2 and 3

*#

fn primes (max uint) []uint {
   be prime_list = (2, 3)
   ret prime_list

   for i in 5 -> max +> 2 {
      # Generate primes here
   }
}

#######################################
######### FIBONACCI GENERATOR #########
#######################################

# This function will run indefinitely.
fn fibonacci () [uint] {
   be f = (0, 1)
   ret f

   for {
      f += f(f.l - 1) + f(f.l) # push to f: sum of last two values
   }
}

array.l # returns array length
array.len # too

# Behind them are getters. Functions that are called without brackets.
# More about structure-methods/ functions/ getters later.

# Here's an exmple how to force the end of a function

be x = fibonacci()  # Start a fibonacci collector
sleep: 1000          # Sleep main thread for 1000 milliseconds
x.leave:             # End x's function thread. This is a method on a
                     # type. More about them, later.
out: x               # [0, 1, 1, 2, 3, 5, 8, 13, 21, ... ]

##################################################
######### INLINE FUNCTIONS - MATH SYNTAX #########
##################################################

fn f (x) {
   exit 2 * x + 5
}

out: f(2)

# the function is is the same as

fn f (x) -> {
   exit 2 * x + 5
}

# is the same as

fn f (x) -> 2 * x + 5

###########################
######### IMPORTS #########
###########################

use (
   'time'                              # Import 'time' library
   'pkg:github.com/Something/proj'     # Import as 'proj'
   '/path/to/file.sc'                  # Import from source
   './path/to/file.sc'                 # Import 'file' from current directory
   '../path/to/file.sc'                # Import 'file' from parent directory
)

# special

use *strict        # strict could forbid declaration of operations, some meta programming, etc.
use (*unsafe *asm) # unsafe could support an 'eval' method to execute string as code
                   # asm could allow direct assembly commands

# "strict" forces strict programming:
#   - no further meta programming
#   - no assembly coding (?)
# "unsafe" could open declarations of variables to outside of code
#   - 'eval' method to JIT-compile strings into the language
# "asm": assembly input
#   - assembly coding in code

###########################################
######### ENTITY COMPONENT SYSTEM #########
###########################################

type EmptyTag # Simple Type

type Position <
   x int
   y int
>

type Velocity <
   x int, y int
>

type Asset <
   image Image
>

be predefinedComp = Velocity (
   x = 5
   y = 5
)

be hero int = new (
   EmptyTag
   Position (
      x = 0
      y = 0
   )
   predefinedComp
   Asset (
      image = Image ()
   )
)

hero.del:

#
# Iterate over component-combinations
#

for eid int in query (Position, Velocity) {
   Position(eid).x += Velocity(eid).x
   Position(eid).y += Velocity(eid).y
}

for eid int in query (Position, Asset) {
   Asset(eid).image.render(Position(eid).x, Position(eid).y)
}

# In case for loop is not nested and
# entity id is not required. Shortcut:

for query (Position, Velocity) {
   Position.x += Velocity.x
   Position.y += Velocity.y
}

for query (Position, Asset) {
   Asset.image.render(Position.x, Position.y)
}

##########
# Vector #
##########

struct Vector (int * 3)

v1 <Vector> = (1, 2, 3)
v2 <Vector> = (4, 5, 6)

Vector {
   $["sum"]
   fn (self, Vector) {

   }
}

out: v1 + v2 # Vector (5, 7, 9)

############################
######### ASSEMBLY #########
############################

use (*asm)

#
# (f - full, optional), h - half, q - quarter
#

rA-f  # First FULL Register     1111 (4 bytes)
rB-h  # Second HALF Register    0011 (2 bytes)
rC-q  # Third QUARTER Register  0001 (1 byte)
rD    # Fourth Register (full by default)

#
# Assembly Flags
#

fO # Overflow Flag:        High-order bit overflow after arithmetic operation
fD # Direction Flag:
fI # Interrupt Flag:
fT # Trap Flag:
fS # Sign Flag:            Sign of result of arithmetic operation
fZ # Zero Flag:            Result of arihtmetic operation is zero
fA # Auxiliary Carry Flag: 
fP # Parity Flag:          Amount of zeros after arithmetic operation
fC # Carry Flag:           Overflow/ Carry:   1010 + 1011 = 1, 0101

#
# OTHER LANGUAGES BUILT IN
#

# JavaScript Built-In
js (
   function k {
      let k = 'Hello, World!'
      console.log(k)
   }
)

# Lua Built-In (or not)
#*lua (
   function k ()
      local k = "Hello, World!"
      print (k)
   end
)*#

# Html Built-In
</
   <tag attribute="value">
      <b>Hello, {{
         "World!"
      }}!</b>
   </tag>
/>

fn getHtml() {
   exit </<b>Hello, World!</b>/>
}

# Assembly Writing
asm (
   mov %eax, %edx
   add %eax, 2
)

#############################
# ABSOLUTE META PROGRAMMING #
#############################
#
# Meta program parse-time

$$ {

   # You can declare some state variables here, for example,
   # you could make some sort of calculation how much a variable was used.

   $emit (c str) bool {
      # c is the substring: current parse location to end
      # called every parse event
      # return true if claimed

      exit c * r'^start_here'
   }
   
   # Return how many characters you have read.
   $parse (c str) int {
      be x := 0

      loop {
         if c * r'^end_or_so' exit

         x += 1
         c := c.sub(1)

         if c == '' exit
      }

      exit x
   }

   fn parser(content str) [str] {
      be tokens [str] = []

      loop {
         if content * '^2' {
            tokens.push('2')
            next
         } else if content * '^\+' {
            tokens.push('\+')
            next
         }

         content := content.sub(1)
         if content == '' exit
      }

      exit tokens
   }

   # You can also return a string, and raw Script code.
   $execute (content str) code {
      be tokens = parser(content)
      exit {
         out tokens.filter(e -> e == '2').len
      }
   }
}

start_here
   2 + 2
end_or_so

# outputs 4

# you could write api's with that, for example something like rest.