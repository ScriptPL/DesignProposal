
# DEFINING A PACKAGE

pkg main

# BASICS

methods:
@attributes
$definitions
{ code block }
( values or types )

type ( type_content )
value <of type>
<type conversion for> value

#########
# TYPES #
#########

null            # value/type null
int             # Integer
[]int           # List of integers
[5]int          # Array of integers with five elements.
[int, str * 3]  # Tuple with 1 = integer, followed by three strings: TYPE * AMOUNT
Type[T]         # Type with type specification
[int | '0']     # Type Collection -> Quick Enum: Integer or '0'

##########################################################################################
#########                                    LOOPS                               #########
##########################################################################################

# Code repetetion / loop

be i int = 5                # for ( i = s;
for {                       # standalone; for {} is a while true loop
    if i < end_value exit   # i < end_value ;
    # Content
    i += 1                  # i ++
}

for 5 {
    # repeat five times
}

for condition {
    # while condition
}

for i := 0; i < end_value; i += 1 {
    # traditional for loop
}

for i, e in arr {
    # for elements of an array
}

for ... in iter {
    # for over an iterable
}

for iterable {
    # for over an iterable function
}

{
    next # continue
    exit # break
}

for i, e in s -> e { }        # for (i = s; i <= e; i++)
for i in 5 -> inf +> 2 { }    # for (i = 5; true; i += 2); i = 5, while { i += 2 }


##########################################################################################
#########                              CONDITIONS                                #########
##########################################################################################

################################### BOOLEAN STATEMENTS ###################################

a < b <= c < d    # equivalent to:     a < b && b <= c && c < d
a == b == c       # equivalent to:     a == b && b == c
a < b == c < d    # equivalent to:     a < b && b == c && c < d
a > b > c         # also possible

# ILLEGAL
a < b > c         # but: could technically be interpreted as a < b && b > a
a > b < c         # therefore... could be legal?

##################################### CONTROL FLOW ######################################

# if statement
if c {}
# else if statement
elif c {}
# else statement
el {}

###################################### SWITCH CASE ######################################

if value {
    is k {}
    is m {}
}

if value is something {}

##########################################################################################
#########                                    TYPES                               #########
##########################################################################################

type AbstractType # Acts like a tag

type Collection (
    str |
    int
)

be x Collection = 500
x = 'Hello!'

type Enum (
    be Value1 |
    be pub Value2
)

z := Enum.Value1
z = Value2

type Struct (
    x int
    y str
)

s := Struct (
    x = 5
    y = 'Hello, World!'
)

# Optional Values

type ComplexStruct (
    x int
    y int?
)

# Complex Types

type Structure (
    x int,
    y bool,
    z (
        z1 int,
        z2 bool
    )
)

c := Structure (
    x = 5,
    y = true,
    z = (
        z1 = -5,
        z2 = false
    )
)

type StringEnum (
    'content' |
    'hello'
)

##########################################################################################
#########                               GENERATED TYPES                          #########
##########################################################################################

################################# NUMERIC ARRAYS / RANGES ################################

# start_value -> end_value +> step
5 -> 10        # (5, 6, 7, 8, 9, 10)
(5 -> 10) *= 2 # (10, 12, 14, 16, 18, 20) # array *= n creates new array, acts like filter
5 -> 10 +> 2   # (5, 7, 9)

################################# NUMERIC ARRAYS / RANGES ################################

##########################################################################################
#########                                   METHODS                              #########
##########################################################################################

fn Structure.sum() {
    # Just declare the function of pattern TYPE:METHOD
}

# Or enter the type scope and write functions there

Structure {
    fn sum() {
        # Anything you wish
    }
}

be x Structure

x.sum()