

##########################################################################################
#########                                  BASICS                                #########
##########################################################################################

# Brackets
{code}
(value)
(type)
<labels>

# Functions
call(params)
call: params

be:g    # declare a global
be:c    # declare a constant
be:g:c  # declare a global constant

case value
case:t type

##########################################################################################
#########                                 SCOPES                                 #########
##########################################################################################

a {
    # self = a
    b.c {
        # self = a.b.c
        d {
            # self = a.b.c.d
        }
    }

    fn e () {
        # fn a.e
    }
}

fn a.b.f () {
    # fn a.b.f
}

##########################################################################################
#########                               FUNCTIONS                               #########
##########################################################################################

fn name (parameter int = default, ...) return_type {
    # do smt
    ret return_value
    exit exit_value
}

###################################### MANY OUTPUTS ######################################

fn example () int, str, bool {
    exit 5, 'Hi!', true
}

be a, b, c = example()

################################# STACKABLE OPTIMIZATION #################################

out: 'Hello!'
out: 'How are you?', 'I\'m fine!'
out: 'You?'

# optimised compile time into out: 'Hello!', 'How are you?', 'I\'m fine', 'You?', if no statement is inbetween.

$[opt stack]
fn out (params [...]str) {
    ...
}

##########################################################################################
#########                                 LOOPS                                  #########
##########################################################################################

for {
    # loop indefinitely
}

for number {
    # repeat n times
}

for condition {
    # while condition
}

for be i = start_value; i < end_value; i += 1 {
    # traditional for loop
}

i int = 5                 # for ( i = s;
for {                       # standalone; for {} is a while true loop
    if i < end_value exit   # i < end_value ;
    # Content
    i += 1                  # i ++
}


for i, e in arr {
    # for elements of an array
}

for ... in iter {
    # for over an iterable
}

for iterable {
    # for over an iterable function
}

{
    next    # continue
    ret     # break, but keep running in a nameless thread
    exit    # break
}

for i in (begin = 5, jump = 2) {
    # for in <struct>: begin: start; end: last accepted value or inf; jump: increment
}

###################################### SCOPE LABEL #######################################

be value

for<x> y {
    for z {
        exit<x> value
    }
}

out: y == value # true

##########################################################################################
#########                              CONDITIONS                                #########
##########################################################################################

################################### BOOLEAN STATEMENTS ###################################

a < b <= c < d    # equivalent to:     a < b && b <= c && c < d
a == b == c       # equivalent to:     a == b && b == c
a < b == c < d    # equivalent to:     a < b && b == c && c < d
a > b > c         # also possible

# ILLEGAL
a < b > c         # but: could technically be interpreted as a < b && b > a
a > b < c         # therefore... could be legal?

##################################### CONTROL FLOW ######################################

# if statement
if c {}
# else if statement
elif c {}
# else statement
el {}

###################################### SWITCH CASE ######################################

if value { # s stays for switch
    case k
        # code
    case m
        # code
}

if value {
    case val1, val2, val3
        # Match val1, val2 or val3

    case:t Type
        # Match if is type

    el
        # Nothing matched
}

############################### SWITCH CASE WITH FUNCTIONS ###############################

fn str.equalsSize(i int) bool, str {
    if self.len == i {
        exit true, 'v is this string'
    }
    exit false, ''
}

if 'Hello, World!'.equalsSize {
    case 13 -> v {
        out: v
    }
}

##########################################################################################
#########                                  TYPES                                 #########
##########################################################################################

######################################## TAG TYPE ########################################

type AbstractType   # Acts like a tag

####################################### TYPE = TYPE ######################################

type Type = DifferentType(More)

be k Type = ...

####################################### TYPE = ENUM ######################################

type Enum (
    *Member1 |
    *Member2(More) |
    *Member3(AndMore)
)

be k Enum = Enum.Member1
be k = Enum.Member1 # This language is not to be verbose! Everything that's obvious is obvious!!!

# UNPACK ENUM #

k = Enum.Member2(More)

if be Enum.Member2(content) = k {
    # Unpacks content from the enum
} elif be Enum.Member1 = k {
    # k = Enum.Member1
}

#################################### TYPE = COLLECTION ###################################

type Values (
    str |
    num |
    bool |
)

be k Values = 'Hello!'

###################################### TYPE = STRUCT #####################################

type Struct (
    abc Type1
    def Type2
)

be k Struct = Struct (abc = ..., def = ...)
be k Struct = (abc = ..., def = ...)
be k = Struct (abc = ..., def = ...)

###################################### TYPE = TUPLE ######################################

type Tuple (Type1, Type2, Type3)

be k Tuple = Tuple (a, b, ...)
be k Tuple = (a, b, ...)
be k = Tuple (a, b, ...)

###################################### COMPLEX TYPE ######################################

# Type Collection
type ComplexType (
    str | int | *Hello

    |
    var Type,
    anotherVar DifferentType

    |
    Type, SecondType, str
)

be k ComplexType
k = 'string'
k = 500
k = ComplexType.Hello
k = (var = ..., anotherVar = ...)
k = (Type, SecondType, ...)

####################################  RECURSIVE TYPES ####################################

type Array: Content (*M(Content, self) | * E)

Array(Content) {
    fn self (pos uint) Content {
        # Get element at pos
    }

    fn push (element Content) {
        be latest @Array(Content) = self
        for {
            if latest {
                case Array.M {
                    latest = latest.1
                }

                case Array.E {
                    latest = Array.M(element, Array.E)
                }
            }
        }
    }
}

arr #*Array(str)*# = Array.M('Hello!', Array.M('all', Array.M('people', Array.E)))
arr.push()  # Array(T).push fn push {}
arr(0)      # Array(T)()    fn self (int) {}

########################################## ARRAYS ########################################

s = (2, 4, 104, 12) # Upon compile time reads as value = (2, 4, 104, 12).
                    # You can then make a [int, uint, int7 (or more) or uint7 (or
                    # more) or num] <()int>, <(4)int>: It will keep acting like a
                    # integer array with 4 elements unless it is extended
                    # Limit of extension: <()num>

be k List(str) = ('Hello!', 'Za Warudo!', 'World!')
# be k <(3)str>

######################################### TUPLES #########################################

type Tuple (int, str, bool)

be y Tuple = (5, 'Something', true) # technically the same as
y = Tuple (5, 'Something', true)   # conversion vs assignment

type AnotherTuple (int, str * 3)

be z AnotherTuple = (5, 'A', 'BC', 'DEF')

#################################### COLLECTIVE ENUM ####################################

type Result: Success, Error (*Ok(Success), *Err(Error))

be k Result(int, str) = Result.Ok(200)
k = Result.Err('Could not connect!')

if be Result.Err(m) = k {
    out: m
}

######################################## REFERENCE #######################################

@Type # a pointer

##################################### TYPE AND VALUE #####################################

type TypeValuePair = Map<Comp>(T(Comp), Map(uint, Comp)) #??????

type ABC (de int, fg int)

be k TypeValuePair

k.(T(ABC)) = Map(uint, ABC)
k.(T(ABC)).(0) = ABC (de = 5, fg = 10)

#
# type Type     = a type, acts like one
# T(Type)       = the type id, typeof uint
#

##########################################################################################
#########                               EXAMPLE SCOPE                            #########
##########################################################################################

# Just the scope "API"
API {
    fn connect () {

    }
}

# Access functions in the scope
API.connect()

##########################################################################################
#########                                 LAZY LOGIC                             #########
##########################################################################################

if k for if y {
    # if k  # if k  # if k equals true enter "next scope"
    # for   # for   # and loop indefinitely.
    # if y  # if y  # if y is true, run the code block, otherwise continue

    ###
}

# is the same as

if k {
    for {
        if y {
            ###
        }
    }
}


##########################################################################################
#########                               QUICK SYNTAX                             #########
##########################################################################################

k = true ? 'True' ~ 'False'

############################## SHORT ENTITY COMPONENT SYSTEM #############################

# Without specifying the entity id, just quickly operate over all
for query (Player, Position, Velocity) {
   Position.x += Velocity.x
   Position.y += Velocity.y
}

##########################################################################################
#########                                 ITERABLES                              #########
##########################################################################################

# iterable functions
fn iter(a int = 0, b int = 10) int, int {
    be:g i = a

    $["before"]
    fn {
        exit a < b  # if true, continue looping, otherwise, break
    }

    $["after"]
    fn {
        a += 1
    }
}

for a, b in iter {
    out: i  # 0, 1, 9
}

##########################################################################################
#########                                 REGEX                                  #########
##########################################################################################

#
# Repetition Notation:
# {0-}          *   zero or more
# {1-}          +   one or more
# {-1}, {0-1}   ?   zero or one
# {n-n}         {n,n} exactly n
#

´\e{0-1}´

#
# custom regex char set or
# other regex insertions
#

be w = ´[01]´

´$(w){1-}´ # will match 0, 1, 01, etc.

####################################### AAA BBB CCC ######################################

be n int
be proof = 'aaabbbccc'

out: proof * ´(a)${l:n}(b){n}(c){n}´  # true
out: n                          # 3

#
# a${l:n}   # Scan for "l"ength of "a"'s, write into variable n
# b{n}      # Expect "b", n times
# c{n}      # Expect "c", n times
#

# ${}:      write into code
# $(), {}:  read from code

#
# ${l:var}  capture group length
# ${s:var}  capture group string
# ${b:var}  is the capture group emitted?: E.g. ´(bool)?${b:var}vvv´ returns true for 'boolvvv', but not 'vvv'
#

be map Map(str, str)
be k = 'h="Hello";g="World";z="Ocean";'

for key, value in k * ´(\w)${1}="(\w)${2}";´ {
    map.(key) = value 
}

out: map.('h') .. ', ' .. map.('g')    # Hello, World!

##########################################################################################
#########                         ENTITY COMPONENT SYSTEM                        #########
##########################################################################################
#
# A built-in entity system is provided. To create a new entity, use the keyword new with
# a set of type structures.
#

Entity {
    be id uint = 0
    be map Map(T, Map(uint, _))

    fn self() {
        exit id += 1
    }

    # Add Component
    fn add(comp _) {
        $[compile time] {
            # Compile time make sure that the map object has a proper hierarchy
            be map.(T(comp)) Map(uint, T(comp))

            # Writes into the type as if it's controlling it:
            # Creates Position.(uint) for Position if Position is passed into here.
            T(comp) {
                fn self (id uint) T(comp) {
                    exit map.(T(comp)).(id)
                }
            }
        }

        # Trust what we did in compile time: The following won't panic!
        $[trust] be Map(uint, T(comp)) = map.(T(comp))

        # Set the component
        be map.(T(comp)).(self.id) = comp # map.comp_type.eid = comp
    }

    # Query
    fn capture(comps [... T]) func {
        be entities List(uint)

        for _, e in comps {
            # Hmm
        }

        exit entities.iterator
    }
}

type Player
type Position (x int, y int)
type Velocity (x int, y int)

be player = Entity.()

player.add(Player)
player.add(Position (x = 50, y = 50))
player.add(Velocity (x = -1, y = -1))

be entities = Entity.capture (Player, Position, Velocity)

for eid uint in entities {
   Position.(eid).x += Velocity.(eid).x
   Position.(eid).y += Velocity.(eid).y
}