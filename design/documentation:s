

##########################################################################################
#########                                  BASICS                                #########
##########################################################################################

# Brackets
{code}
(value)
<type>

# Functions
call(params)
call: params

# Other
for:label # loop with label

be:g    # declare a global
be:c    # declare a constant
be:g:c  # declare a global constant

##########################################################################################
#########                                 SCOPES                                 #########
##########################################################################################

a {
    # self = a
    b.c {
        # self = a.b.c
        d {
            # self = a.b.c.d
        }
    }

    fn e () {
        # fn a.e
    }
}

fn a.b.f () {
    # fn a.b.f
}

##########################################################################################
#########                               FUNCTIONS                               #########
##########################################################################################

fn name (parameter <int> = default, ...) <return_type> {
    # do smt
    ret return_value
    exit exit_value
}

##########################################################################################
#########                                 LOOPS                                  #########
##########################################################################################

for {
    # loop indefinitely
}

for number {
    # repeat n times
}

for condition {
    # while condition
}

for be i = start_value; i < end_value; i += 1 {
    # traditional for loop
}

i <int> = 5                 # for ( i = s;
for {                       # standalone; for {} is a while true loop
    if i < end_value exit   # i < end_value ;
    # Content
    i += 1                  # i ++
}


for i, e in arr {
    # for elements of an array
}

for ... in iter {
    # for over an iterable
}

for iterable {
    # for over an iterable function
}

{
    next    # continue
    ret     # break, but keep running in a nameless thread
    exit    # break
}

for i in (begin = 5, jump = 2) {
    # for in <struct>: begin: start; end: last accepted value or inf; jump: increment
}

###################################### SCOPE LABEL #######################################

be value

for:x y {
    for z {
        exit:x value
    }
}

out: y == value # true

##########################################################################################
#########                              CONDITIONS                                #########
##########################################################################################

################################### BOOLEAN STATEMENTS ###################################

a < b <= c < d    # equivalent to:     a < b && b <= c && c < d
a == b == c       # equivalent to:     a == b && b == c
a < b == c < d    # equivalent to:     a < b && b == c && c < d
a > b > c         # also possible

# ILLEGAL
a < b > c         # but: could technically be interpreted as a < b && b > a
a > b < c         # therefore... could be legal?

##################################### CONTROL FLOW ######################################

# if statement
if c {}
# else if statement
elif c {}
# else statement
el {}

###################################### SWITCH CASE ######################################

if value { # s stays for switch
    case k
        # code
    case m
        # code
}

if value {
    case val1, val2, val3
        # Match val1, val2 or val3

    case is Type
        # Match if is type

    el
        # Nothing matched
}

if value is something {}

############################### SWITCH CASE WITH FUNCTIONS ###############################
#
# if <func<any "input"><bool "output", "with" params>> {
#     is input with params {
#         # if the first "bool" return of the function is true, continue here
#     }
# }
#

fn str.equalsSize(i <int>) <bool>, <str> {
    if self.len == i {
        exit true, 'V is this string'
    }
    exit false, ''
}

if 'Hello, World!'.equalsSize {
    case 13 -> v {
        out: v
    }
}

####################################### UNPACK ENUM ######################################

type A <<*B> | <*C(str)>>

k = A.B
k = A.C ('Hello!')

if k is A.B {
    # Does nothing
} elif k is A.C(v) {
    out: v  # Hello!
}

##########################################################################################
#########                                   TYPES                                #########
##########################################################################################

# Type Collection
type TypeName <
    # Use existing types into a collection
    <str>
    | <int>

    | # Or create new enum components with a star
    <*Hello>

    | # Struct: Collection of parameters

    var Type,
    anotherVar DifferentType

    | # Tuple

    1 Type
    2 SecondType
    3 str

    | # Quick Tuple

    Type, SecondType, str
>

####################################### SCOPE TYPE #######################################
# AND
####################################  RECURSIVE TYPES ####################################

type Array(T) <
    <*M(T, self)> |
    <*E>
>

Array(T) {
    fn push (element T) {
        be latest <@Array<T>> = self
        for {
            if latest {
                case Array.M {
                    latest = latest.1
                }

                case Array.E {
                    latest = Array.M(element, Array.E)
                }
            }
        }
    }
}

arr #*Array<str>*# = Array.M('Hello!', Array.M('all', Array.M('people', Array.E)))
arr.push() # Array<T.push> with self

######################################### TAG TYPE #######################################

type AbstractType   # Acts like a tag

################################ COLLECTION OF EXISTING TYPES ############################

type Collection <
    <str> |
    <int>
>

be x <Collection> = 500
x = 'Hello!'

########################################### ENUM #########################################

type Enum <
    <*Value1> |
    <*Value2>
>

type StringEnum <
    'content' |
    'hello'
>

z = Enum.Value1
z = Value2

########################################## STRUCT ########################################

type Struct <
    x <int>
    y <str>
    _z <bool> # Values starting with an underscore make the variable private.
>

s = Struct (
    x = 5
    y = 'Hello, World!',
    _z = true
)

s <Struct> = (
    x = 5
    y = 'Hello, World!',
    _z = true
)

########################################## ARRAYS ########################################

s = (2, 4, 104, 12) # Upon compile time reads as value = (2, 4, 104, 12).
                    # You can then make a [int, uint, int7 (or more) or uint7 (or
                    # more) or num] <()int>, <(4)int>: It will keep acting like a
                    # integer array with 4 elements unless it is extended
                    # Limit of extension: <()num>

be k <()str> = ('Hello!', 'Za Warudo!', 'World!')
# be k <(3)str>

########################################## TUPLES ########################################

type Tuple <int, str, bool>

be y <Tuple> = (5, 'Something', true) # technically the same as
y = Tuple (5, 'Something', true)   # conversion vs assignment

type AnotherTuple <int, str * 3>

be z AnotherTuple = (5, 'A', 'BC', 'DEF')

#################################### COLLECTIVE ENUM ####################################

type Result(Success, Error) <
    <*Ok(Success)> |
    <*Err(Error)>
>

be k <Result<int, str>> = Result.Ok(200)
k = Result.Err('Could not connect!')

if k is Result.Err(m) {
    out: m
}

######################################## REFERENCE #######################################

<@Type> # a pointer

##########################################################################################
#########                                  METHODS                               #########
##########################################################################################

fn Structure.sum() {
    # Just declare the function of pattern TYPE:METHOD
}

# Or enter the type scope and write functions there

Structure {
    fn sum() {
        # Anything you wish
    }
}

be x Structure

x.sum()

##########################################################################################
#########                               EXAMPLE SCOPE                            #########
##########################################################################################

# Just the scope "API"
API {
    fn connect () {

    }
}

# Access functions in the scope
API.connect()

##########################################################################################
#########                                 LAZY LOGIC                             #########
##########################################################################################

if k for if y {
    # if k  # if k  # if k equals true enter "next scope"
    # for   # for   # and loop indefinitely.
    # if y  # if y  # if y is true, run the code block, otherwise continue

    ###
}

# is the same as

if k {
    for {
        if y {
            ###
        }
    }
}


##########################################################################################
#########                               QUICK SYNTAX                             #########
##########################################################################################

k = true ? 'True' ~ 'False'

############################## SHORT ENTITY COMPONENT SYSTEM #############################

# Without specifying the entity id, just quickly operate over all
for query (Player, Position, Velocity) {
   Position.x += Velocity.x
   Position.y += Velocity.y
}

##########################################################################################
#########                                 ITERABLES                              #########
##########################################################################################

# iterable functions
fn iter(a int = 0, b int = 10) <int, int> {
    be:g i = a

    fn:before {
        exit a < b  # if true, continue looping, otherwise, break
    }

    fn:after {
        a += 1
    }
}

for a, b in iter {
    out: i  # 0, 1, 9
}

##########################################################################################
#########                           QUICK FUNCTION CALLS                         #########
##########################################################################################

fn execute (x code) {
    x.exec()
}

execute: {

}

##########################################################################################
#########                                 REGEX                                  #########
##########################################################################################

#
# Repetition Notation:
# {0-}          *   zero or more
# {1-}          +   one or more
# {-1}, {0-1}   ?   zero or one
# {}
#

´\e{0-1*1}´

#
# custom regex char set or
# other regex insertions
#

be w #*<regex.set>*# = regex.set('0', '1') # regex.set(('0', '1')): one bracket for function, one for array "technically"

´$(w){1-}´ # will match 0, 1, 01, etc.

############################# MACRO ON THE REGEX SET EXAMPLE #############################

regex {
    type set <()char>

    #fn set (chars <... char>) {
    #    exit chars
    #}

    # Since tuples with one value evaporate their brackets, regex.set('0', '1') is a type followed by an array.
}

####################################### AAA BBB CCC ######################################

be n int
be proof = 'aaabbbccc'

out: proof * ´(a)${i:n}(b){n}(c){n}´  # true
out: n                          # 3

#
# a${i:n}   # Scan for "i"nteger amount of "a"'s, write into variable n
# b{n}      # Expect "b", n times
# c{n}      # Expect "c", n times
#

# ${}:      write into code
# $(), {}:  read from code

be map <Map(str, str)>
be k = 'h="Hello";g="World";z="Ocean";'

for key, value in k * ´(\w)${1}="(\w)${2}";´ {
    map(key) = value 
}

out: map('h') .. ', ' .. map('g')    # Hello, World!

