
# DEFINING A PACKAGE

pkg main

# BASICS

methods:
@attributes
$definitions
{ code block }
( values )
value
[ type ]
value [of type]
[type conversion for] value

#########
# TYPES #
#########

null            # Type and value
int             # Integer
[]int           # List of integers
[5]int          # Array of integers with five elements.
[int, str * 3]  # Tuple with 1 = integer, followed by three strings
Type[T]         # Type with type specification
[int | '0']     # Type Collection -> Quick Enum: Integer or '0'

################
# CONTROL FLOW #
################

# Code repetetion / loop

be i int = 5                # for ( i = s;
for {                       # standalone; for {} is a while true loop
    if i < end_value do end # i < end_value ;
    # Content
    i += 1                  # i ++
}

for 5 {
    # repeat five times
}

for condition {
    # while condition
}

for i := 0; i < end_value; i += 1 {
    # traditional for loop
}

for i, e in arr {
    # for elements of an array
}

for ... in iter {
    # for over an iterable
}

for iterable {
    # for over an iterable function
}

{
    next # continue
    end  # break
}

# Range Set

[start_value --> end_value] # Defines a quick range (invisible array): (start, start + 1, ..., end)

for i, e in [s --> e] { }        # for (i = s; i <= e; i++)
for i in [5 --> inf] += 2 { }    # for (i = 5; true; i += 2); i = 5, while { i += 2 }

# Conditional operators are stackable

a < b <= c < d    # equivalent to:     a < b && b <= c && c < d
a == b == c       # equivalent to:     a == b && b == c
a < b == c < d    # equivalent to:     a < b && b == c && c < d
a > b > c         # also possible

# ILLEGAL
a < b > c         # but: could technically be interpreted as a < b && b > a
a > b < c         # therefore... could be legal?

if c { }            # if statement
elif c { }          # else if statement
el {}               # else statement

if value {
    is k {}
    is m do something
}

if value is something {}
if value is something do something
if condition do somthing

####################
# TYPE DEFINITIONS #
####################

# Type without content, a very simple type

type SimpleType

# Enum

type Enum [
    new Element1 | # New defines a new simply type as subtype of the enum.
    new Element2 |
    pub new Element3 | # Pub unpacks enum type
    str # String Type
]

# Usage:

Enum.Element1
Enum.Element2
Enum.Element3
Element3        # pub keyword instantly unpacks content.

# Collection

type Token [
    [str] | # use indicates
    bool |
    9 |
    'content'
]

t Token := 9

# Structures, Component Structures

type Structure [
    x int,
    y bool,
    z [
        z1 int,
        z2 bool
    ]
]

type Velocity [
    x num,
    y num
]

x := Structure (
    x = 5,
    y = true,
    z = (
        z1 = -5,
        z2 = false
    )
)

# Type methods

fn Structure.sum() {
    # Just declare the function of pattern TYPE:METHOD
}

# Or enter the type scope and write functions there

Structure {
    fn sum() {
        # Anything you wish
    }
}

x.sum()