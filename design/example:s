
pkg main

##########################################################################################
#########                           FACTORIAL FUNCTION                           #########
##########################################################################################

fn factorial (n uint) uint {
    if n <= 1
        exit 1
    elif # this line can be comment technically
        exit this(n - 1) * n # you can "exit self( ..." to indicate calling yourself
}

fn factorial (n uint) uint {
    r := 1
    for i in 1 -> n {
        r *= n
    }
    ret n
}

##########################################################################################
#########                               OUTPUT PRINT                             #########
##########################################################################################

out: 'Hello, World!'

##########################################################################################
#########                                 METHODS                                #########
##########################################################################################
#
# Ways to call a function:
# hello (params)    # Function with return value
# hello: params     # Method
#

fn print_element (...params any) {
    for i, e in params {
        if e { # if it's a non-boolean value, act like a switch
            is str {
                out: e, b0A
            }

            is int {
                out: <str> e, b0A # Parse integer to string
            }

            is bool {
                if e {
                    out: 'true', b0A
                } el {
                    out: 'false', b0A
                }
            }
        }
    }
}

print_element: 'Hello', 5, false

##########################################################################################
#########                         ENTITY COMPONENT SYSTEM                        #########
##########################################################################################
#
# A built-in entity system is provided. To create a new entity, use the keyword new with
# a set of type structures.
#

type Player

type Position (
    x int
    y int
)

type Velocity (
    x int
    y int
)

player int := new (
    Player,
    Position (
        x = 0,
        y = 5
    )
)

# Queries are compile time optimized.
for eid int in query (Player, Position, Velocity) {
   Position(eid).x += Velocity(eid).x
   Position(eid).y += Velocity(eid).y
}

##########################################################################################
#########                                 STRUCTS                                #########
##########################################################################################

type Struct (
    x int
    y int
)

s := Struct (
    x = 5
    y = 15
)

MetaType := type (
    z str
)

out: s.x

##########################################################################################
#########                               OPERATIONS                               #########
##########################################################################################

######################################### STRINGS ########################################

string str := 'Hello, World!'

string += ' Add more!'      # "Hello World! Add more!"              += add string
string =- 10                # "Hello World!"                        =- remove n characters from end
string -= 6                 # "World!"                              -= remove n characters from start
string *= 3                 # "World!World!World!"                  *= repeat string n times

######################################### ARRAYS #########################################

array []int := (1, 2, 3, 4)

array += 5                  # (1, 2, 3, 4, 5)                       += push
array /= I == 0 || V > 3    # (2, 3); I is index, V is element      /= quick filter
array += 4, 5, 6            # (2, 3, 4, 5, 6)
array -= 2, 3               # (2, 3, 6)                             -= remove elements at pos

######################################### BOOLEAN ########################################

k := true

k!  # Set the boolean to the opposite 

######################################### NUMERIC ########################################

k := 50000

k +=   500  # each represent arithmetic operations
k -=  1000
k *= 2
k /= 100
k %= 990    # 0

##########################################################################################
#########                             PRIME GENERATION                           #########
##########################################################################################

fn genPrimes (total int) {
    primes []int := (2, 3)

    for i in 5 -> total +> 2 {
        isPrime := true

        for j, e in primes {
            if e % i == 0 {
                isPrime = false
                exit
            }
        }

        if isPrime {
            primes += i
        }
    }

    exit primes
}

out: genPrimes (500)

################################# NUMERIC ARRAYS / RANGES ################################

fn genPrimes (total int) {
    primes := 2 -> total

    for i in primes {
        if i == 0 next

        for j in 2 * i -> total +> i {
            # ALL variables in this language are passed down as references
            # Cloning goes with the & attribute
            i = 0
        }
    }

    # /= Filter out by condition
    primes /= V != 0

    exit primes
}

out: genPrimes (500)

##########################################################################################
#########                        READABLE GAMEDEV SETUP                          #########
##########################################################################################

# use html

App {
    be canvas
    be x, y int
    be keys Tags<str>

    fn init() {
        canvas = document.getElementById('#canvas')

        x = canvas.width * .5
        y = canvas.height * .5

        animationFrame:
        addEventListeners:
    }

    fn animationFrame() {
        update:
        render:
    }

    fn update() {
        be xDir = keys.has('a') ? -1 : 0 + keys.has('d') ? 1 : 0
        be yDir = keys.has('w') ? -1 : 0 + keys.has('s') ? 1 : 0

        x, y += xDir, yDir
    }

    fn render() {
        canvas.fillColor = 'black'
        canvas.fillRect(0, 0, canvas.width, canvas.height)

        canvas.fillColor = 'white'
        canvas.fillRect(x - 10, y - 10, 20, 20)
    }

    fn addEventListeners() {
        document.addEventListener('keydown', event => {
            keys.push(event.key.toLower())
		})

		document.addEventListener('keyup', event => {
            keys.remove(event.key.toLower())
		})
    }
}

window.onload: {
    App.init()
}