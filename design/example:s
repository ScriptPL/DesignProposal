

##########################################################################################
#########                                  GCD                                   #########
##########################################################################################

fn gdc(a uint, b uint) {
    # JS: https://stackoverflow.com/a/17445307/16002144
    if a == 0
        exit b

    for b != 0 {
        if a > b
            a -= b
        el
            b -= a
    }

    exit a
}

out: gcd(2, 5)

##########################################################################################
#########                           FACTORIAL FUNCTION                           #########
##########################################################################################

fn factorial (n uint) uint {
    if n <= 1
        exit 1
    el # this line can be comment technically
        exit this(n - 1) * n # you can "exit self( ..." to indicate calling yourself
}

fn factorial (n uint) uint {
    be r = 1
    for i in (begin = 1, end = n) {
        r *= n
    }
    ret n
}

##########################################################################################
#########                               FIBONACCI                                #########
##########################################################################################

use '@lib/thread'

fn fibonacci () []uint {
   ret be f = (0, 1)

   for {
      f += f(f.l - 1) + f(f.l) # push to f: sum of last two values
   }
}

be k = fibonacci()

thread.sleep: 5000
out: k.to(str)

##########################################################################################
#########                               OUTPUT PRINT                             #########
##########################################################################################

out: 'Hello, World!'

##########################################################################################
#########                                 METHODS                                #########
##########################################################################################
#
# Ways to call a function:
# hello (params)    # Function with return value
# hello: params     # Method
#

fn print_element (params [...]) {
    for i, e in params {
        if e {
            case:t str
                out: e, b0A
            
            case:t int
                out: e.to(str), b0A

            case:t bool
                out: e ? 'true' ~ false, b0A
        }
    }
}

print_element: 'Hello', 5, false

##########################################################################################
#########                               OPERATIONS                               #########
##########################################################################################

######################################### STRINGS ########################################

be string str = 'Hello, World!'

string += ' Add more!'      # "Hello World! Add more!"              += add string

######################################### ARRAYS #########################################

array []int = (1, 2, 3, 4)

array += 5                  # (1, 2, 3, 4, 5)                       += push
array /= I == 0 || V > 3    # (2, 3); I is index, V is element      /= quick filter
array += 4, 5, 6            # (2, 3, 4, 5, 6)
array -= 2, 3               # (2, 3, 6)                             -= remove elements at pos

######################################### BOOLEAN ########################################

k = true

k!  # Set the boolean to the opposite 

######################################### NUMERIC ########################################

k = 50000

k +=   500  # each represent arithmetic operations
k -=  1000
k *= 2
k /= 100
k %= 990    # 0

##########################################################################################
#########                             PRIME GENERATION                           #########
##########################################################################################

fn genPrimes (total int) []int {
    primes []int = (2, 3)

    for i in (begin = 5, end = total, jump = 2) {
        isPrime = true

        for j, e in primes {
            if e % i == 0 {
                isPrime = false
                exit
            }
        }

        if isPrime {
            primes += i
        }
    }

    exit primes
}

out: genPrimes (500)

##########################################################################################
#########                        READABLE GAMEDEV SETUP                          #########
##########################################################################################

# use html

App {
    be canvas HTMLCanvasElement
    be x, y int
    be keys Tags(str)

    fn init() {
        canvas = document.getElementById('#canvas')

        x = canvas.width * .5
        y = canvas.height * .5

        animationFrame:
        addEventListeners:
    }

    fn animationFrame() {
        update:
        render:
    }

    fn update() {
        be xDir = keys.has('a') ? -1 : 0 + keys.has('d') ? 1 : 0
        be yDir = keys.has('w') ? -1 : 0 + keys.has('s') ? 1 : 0

        x, y += xDir, yDir
    }

    fn render() {
        canvas.fillColor = 'black'
        canvas.fillRect(0, 0, canvas.width, canvas.height)

        canvas.fillColor = 'white'
        canvas.fillRect(x - 10, y - 10, 20, 20)
    }

    fn addEventListeners() {
        document.addEventListener('keydown', event => {
            keys.push(event.key.toLower())
		})

		document.addEventListener('keyup', event => {
            keys.remove(event.key.toLower())
		})
    }
}

window.onload: {
    App.init()
}

##########################################################################################
#########            IMPROVED REGEX CAPABILITIES ~ QUICK HTML PARSER             #########
##########################################################################################

type HtmlElement (name str, content (List(self) | str))

be text = '<b><i>Hello</i>, <u>World</u>!</b>'

fn parseHTML (t str) List(HtmlElement) {
    be output List(HtmlElement) = ()

    be tokens = t.tokenize(´<\w>|<\/\w>|[/<]+´) # List(str)
    be position @List(HtmlElement) = output

    for _, e in tokens {
        be k str
        if e * ´<(\w)${s:k}>´ {
            position.push(name = k, content = ())
            position = position.last().content
        } elif e *´<\/(\w)${s:k}>´ {
            position = position.super
            if position.name != k throw `</$(k)> closes <$(position.name)>`
        } el {
            position.push(e)
        }
    }

    exit output
}

out: parseHTML(text)

#
# b {
#   i {
#     "Hello"
#   }
#   ","
#   u {
#     "World"
#   }
#   "!"
# }

##########################################################################################
#########                                  THROW                                 #########
##########################################################################################

throw 'Throwing an error'
throw:d 'This will only output a deprecation warning!'

##########################################################################################
#########            ADDING DEFAULT ARITHMETIC OPERATIONS TO A CLASS             #########
##########################################################################################

type Vector (num * 3)

Vector {
    fn:sum (self, v Vector) Vector {
        exit Vector (self.0 + v.0, self.1 + v.1, self.2 + v.2)
    }
}

out: Vector(2, 3, 4) + Vector(3, 4, 5)