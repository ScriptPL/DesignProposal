
pkg main

##########################################################################################
#########                                  GCD                                   #########
##########################################################################################

fn gdc(a uint, b uint) {
    # JS: https://stackoverflow.com/a/17445307/16002144
    if a == 0 exit b

    for b != 0 {
        if a > b
            a -= b
        el
            b -= a
    }

    exit a
}

out: gcd(2, 5, 6)

##########################################################################################
#########                           FACTORIAL FUNCTION                           #########
##########################################################################################

fn factorial (n <uint>) <uint> {
    if n <= 1
        exit 1
    elif # this line can be comment technically
        exit this(n - 1) * n # you can "exit self( ..." to indicate calling yourself
}

fn factorial (n <uint>) <uint> {
    r := 1
    for i in 1 -> n {
        r *= n
    }
    ret n
}

##########################################################################################
#########                               OUTPUT PRINT                             #########
##########################################################################################

out: 'Hello, World!'

##########################################################################################
#########                                 METHODS                                #########
##########################################################################################
#
# Ways to call a function:
# hello (params)    # Function with return value
# hello: params     # Method
#

fn print_element (params <...>) { # params <...any>
    for i, e in params {
        if e { # if it's a non-boolean value, act like a switch
            is str {
                out: e, b0A
            }

            is int {
                out: <str> e, b0A # Parse integer to string
            }

            is bool {
                if e {
                    out: 'true', b0A
                } el {
                    out: 'false', b0A
                }
            }
        }
    }
}

print_element: 'Hello', 5, false

##########################################################################################
#########                         ENTITY COMPONENT SYSTEM                        #########
##########################################################################################
#
# A built-in entity system is provided. To create a new entity, use the keyword new with
# a set of type structures.
#

type Player

type Position (
    x <int>
    y <int>
)

type Velocity (
    x <int>
    y <int>
)

player := new (
    Player,
    Position (
        x = 0,
        y = 5
    )
)

# Queries are compile time optimized.
for eid <uint> in query (Player, Position, Velocity) {
   Position(eid).x += Velocity(eid).x
   Position(eid).y += Velocity(eid).y
}

##########################################################################################
#########                               OPERATIONS                               #########
##########################################################################################

######################################### STRINGS ########################################

string <str> := 'Hello, World!'

string += ' Add more!'      # "Hello World! Add more!"              += add string
string -= 0 -> 6            # "World! Add more!"                    -= remove character or character range
string *= 2                 # "World! Add more!World! Add more!"    *= repeat string n times

######################################### ARRAYS #########################################

array <()int> := (1, 2, 3, 4)

array += 5                  # (1, 2, 3, 4, 5)                       += push
array /= I == 0 || V > 3    # (2, 3); I is index, V is element      /= quick filter
array += 4, 5, 6            # (2, 3, 4, 5, 6)
array -= 2, 3               # (2, 3, 6)                             -= remove elements at pos

######################################### BOOLEAN ########################################

k := true

k!  # Set the boolean to the opposite 

######################################### NUMERIC ########################################

k := 50000

k +=   500  # each represent arithmetic operations
k -=  1000
k *= 2
k /= 100
k %= 990    # 0

##########################################################################################
#########                             PRIME GENERATION                           #########
##########################################################################################

fn genPrimes (total <int>) <()int> {
    primes <()int> := (2, 3)

    for i in 5 -> total +> 2 {
        isPrime := true

        for j, e in primes {
            if e % i == 0 {
                isPrime = false
                exit
            }
        }

        if isPrime {
            primes += i
        }
    }

    exit primes
}

out: genPrimes (500)

################################# NUMERIC ARRAYS / RANGES ################################

fn genPrimes (total <int>) <()uint> {
    primes := 2 -> total

    for i in primes {
        if i == 0 next

        for j in 2 * i -> total +> i {
            # ALL variables in this language are passed down as references
            # Cloning goes with the & attribute
            i = 0
        }
    }

    # /= Filter out by condition
    primes /= V != 0

    exit primes
}

out: genPrimes (500)

##########################################################################################
#########                        READABLE GAMEDEV SETUP                          #########
##########################################################################################

# use html

App {
    be canvas
    be x, y <int>
    be keys <Tags<str>>

    fn init() {
        canvas = <HTMLCanvasElement> document.getElementById('#canvas')

        x = canvas.width * .5
        y = canvas.height * .5

        animationFrame:
        addEventListeners:
    }

    fn animationFrame() {
        update:
        render:
    }

    fn update() {
        be xDir = keys.has('a') ? -1 : 0 + keys.has('d') ? 1 : 0
        be yDir = keys.has('w') ? -1 : 0 + keys.has('s') ? 1 : 0

        x, y += xDir, yDir
    }

    fn render() {
        canvas.fillColor = 'black'
        canvas.fillRect(0, 0, canvas.width, canvas.height)

        canvas.fillColor = 'white'
        canvas.fillRect(x - 10, y - 10, 20, 20)
    }

    fn addEventListeners() {
        document.addEventListener('keydown', event => {
            keys.push(event.key.toLower())
		})

		document.addEventListener('keyup', event => {
            keys.remove(event.key.toLower())
		})
    }
}

window.onload: {
    App.init()
}

##########################################################################################
#########            IMPROVED REGEX CAPABILITIES ~ QUICK HTML PARSER             #########
##########################################################################################
#
# PROPOSAL ONLY WITH UNFINISHED DESIGN !!!
#
# CODE WITHOUT CONSTRUCTED LOGIC!
#

type HtmlElement (
    name <str>
    content <()self>
)

be text := '<b><i>Hello</i>, <u>World</u>!</b>'

fn parseHTML (t <str>) <str> {
    be output HtmlElement = (
        name = 'div',
        content = ()
    )

    be latest <ref ()HtmlElement> = output.content

    # ´<\/?\w+>´
    be tagOpen = ´<\w>´
    be tagClose = ´<\/\w>´

    # if function
    if text.startsWith {
        # treats 'is' as the first parameter, where with are return values
        is tagOpen with v {
            latest.push(HtmlElement (
                name = v,
                content = ()
            ))
            latest = latest.last.content
        }

        is tagClose with v {
            latest = latest.super
            if latest.super.name != v throw `</$(v)> closes `
        }
    } el {
        
    }
}

out: parseHTML(text)