
pkg main

##########################################################################################
#########                            FACTORIAL FUNCTIONS                         #########
##########################################################################################

fn factorial (n uint) uint {
    if n <= 1
        exit 1
    elif # this line can be comment technically
        exit this(n - 1) * n # you can "exit self( ..." to indicate calling yourself
}

fn factorial (n uint) uint {
    r := 1
    for i in [1 --> n] {
        r *= n
    }
    ret n
}

##########################################################################################
#########                               OUTPUT PRINT                             #########
##########################################################################################

out: 'Hello, World!'

##########################################################################################
#########                                 METHODS                                #########
##########################################################################################
#
# Functions as set of instructions. No return value, and not stacked. Calling methods to
# form a repetition circle is disallowed.
#

mtd print_element (...params any) {
    for i, e in params {
        if e { # if it's a non-boolean value, act like a switch
            is str {
                out: e, b0A
            }

            is int {
                out: <str> e, b0A # Parse integer to string
            }

            is bool {
                if e {
                    out: 'true', b0A
                } el {
                    out: 'false', b0A
                }
            }
        }
    }
}

print_element: 'Hello', 5, false

##########################################################################################
#########                         ENTITY COMPONENT SYSTEM                        #########
##########################################################################################
#
# A built-in entity system is provided. To create a new entity, use the keyword new with
# a set of type structures.
#

type Player

type Position (
    x int
    y int
)

type Velocity (
    x int
    y int
)

player int := new (
    Player,
    Position (
        x = 0,
        y = 5
    )
)

# Queries are compile time optimized.
for eid int in query (Player, Position, Velocity) {
   Position(eid).x += Velocity(eid).x
   Position(eid).y += Velocity(eid).y
}

##########################################################################################
#########                                 STRUCTS                                #########
##########################################################################################

type Struct (
    x int
    y int
)

s := Struct (
    x = 5
    y = 15
)

MetaType := type (
    z str
)

out: s.x

##########################################################################################
#########                             PRIME GENERATION                           #########
##########################################################################################

fn genPrimes (total int) {
    primes []int := (2, 3)

    for i in (5 --> total) += 2 {
        isPrime := true

        for j, e in primes {
            if e % i == 0 {
                isPrime = false
                exit
            }
        }

        if isPrime {
            primes += i
        }
    }

    exit primes
}

out: genPrimes (500)

##########################################################################################
#########                               EXAMPLE SCOPE                            #########
##########################################################################################

# Declare an API scope
# API := {...}
be API {
    fn connect () {

    }
}

# Access functions in the scope
API.connect()