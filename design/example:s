

##########################################################################################
#########                                  GCD                                   #########
##########################################################################################

fn gdc(a <uint>, b <uint>) {
    # JS: https://stackoverflow.com/a/17445307/16002144
    if a == 0
        exit b

    for b != 0 {
        if a > b
            a -= b
        el
            b -= a
    }

    exit a
}

out: gcd(2, 5)

##########################################################################################
#########                           FACTORIAL FUNCTION                           #########
##########################################################################################

fn factorial (n <uint>) <uint> {
    if n <= 1
        exit 1
    el # this line can be comment technically
        exit this(n - 1) * n # you can "exit self( ..." to indicate calling yourself
}

fn factorial (n <uint>) <uint> {
    be r = 1
    for i in (begin = 1, end = n) {
        r *= n
    }
    ret n
}

##########################################################################################
#########                               FIBONACCI                                #########
##########################################################################################

use '@lib/thread'

fn fibonacci () <()uint> {
   ret be f = (0, 1)

   for {
      f += f(f.l - 1) + f(f.l) # push to f: sum of last two values
   }
}

be k = fibonacci()

thread.sleep: 5000
out: <str> k

##########################################################################################
#########                               OUTPUT PRINT                             #########
##########################################################################################

out: 'Hello, World!'

##########################################################################################
#########                                 METHODS                                #########
##########################################################################################
#
# Ways to call a function:
# hello (params)    # Function with return value
# hello: params     # Method
#

fn print_element (params <(...)>) { # params <...any>
    for i, e in params {
        if:s e {
            case str
                out: e, b0A
            
            case int
                out: e.to(<str>), b0A

            case bool
                out: e ? 'true' ~ false, b0A
        }

        #*if e is str { # if it's a non-boolean value, act like a switch
            out: e, b0A
        } elif e is int {
            out: <str> e, b0A # Parse integer to string
        } elif e is bool {
            out: e ? 'true' ~ 'false', b0A
        }*#
    }
}

print_element: 'Hello', 5, false

##########################################################################################
#########                         ENTITY COMPONENT SYSTEM                        #########
##########################################################################################
#
# A built-in entity system is provided. To create a new entity, use the keyword new with
# a set of type structures.
#

be:g id <uint> = 0

fn entity (components <(...)T>) {
    ret id += 1
    # Something to organise components i suppose
}

fn query (components <(...)T>) <func> {
    
    ret fn (i <uint>) <uint> {

    }
}

type Player

type Position <
    x <int>
    y <int>
>

type Velocity <
    x <int>
    y <int>
>

player = entity (
    Player,
    Position (
        x = 0,
        y = 5
    )
)

for be eid <uint> in query (Player, Position, Velocity) {
   Position(eid).x += Velocity(eid).x
   Position(eid).y += Velocity(eid).y
}

##########################################################################################
#########                               OPERATIONS                               #########
##########################################################################################

######################################### STRINGS ########################################

be string <str> = 'Hello, World!'

string += ' Add more!'      # "Hello World! Add more!"              += add string

######################################### ARRAYS #########################################

array <()int> = (1, 2, 3, 4)

array += 5                  # (1, 2, 3, 4, 5)                       += push
array /= I == 0 || V > 3    # (2, 3); I is index, V is element      /= quick filter
array += 4, 5, 6            # (2, 3, 4, 5, 6)
array -= 2, 3               # (2, 3, 6)                             -= remove elements at pos

######################################### BOOLEAN ########################################

k = true

k!  # Set the boolean to the opposite 

######################################### NUMERIC ########################################

k = 50000

k +=   500  # each represent arithmetic operations
k -=  1000
k *= 2
k /= 100
k %= 990    # 0

##########################################################################################
#########                             PRIME GENERATION                           #########
##########################################################################################

fn genPrimes (total <int>) <()int> {
    primes <()int> = (2, 3)

    for i in (begin = 5, end = total, jump = 2) {
        isPrime = true

        for j, e in primes {
            if e % i == 0 {
                isPrime = false
                exit
            }
        }

        if isPrime {
            primes += i
        }
    }

    exit primes
}

out: genPrimes (500)

##########################################################################################
#########                        READABLE GAMEDEV SETUP                          #########
##########################################################################################

# use html

App {
    be canvas <HTMLCanvasElement>
    be x, y <int>
    be keys <Tags<str>>

    fn init() {
        canvas = document.getElementById('#canvas')

        x = canvas.width * .5
        y = canvas.height * .5

        animationFrame:
        addEventListeners:
    }

    fn animationFrame() {
        update:
        render:
    }

    fn update() {
        be xDir = keys.has('a') ? -1 : 0 + keys.has('d') ? 1 : 0
        be yDir = keys.has('w') ? -1 : 0 + keys.has('s') ? 1 : 0

        x, y += xDir, yDir
    }

    fn render() {
        canvas.fillColor = 'black'
        canvas.fillRect(0, 0, canvas.width, canvas.height)

        canvas.fillColor = 'white'
        canvas.fillRect(x - 10, y - 10, 20, 20)
    }

    fn addEventListeners() {
        document.addEventListener('keydown', event => {
            keys.push(event.key.toLower())
		})

		document.addEventListener('keyup', event => {
            keys.remove(event.key.toLower())
		})
    }
}

window.onload: {
    App.init()
}

##########################################################################################
#########            IMPROVED REGEX CAPABILITIES ~ QUICK HTML PARSER             #########
##########################################################################################
#
# PROPOSAL ONLY WITH UNFINISHED DESIGN !!!
#
# CODE WITHOUT CONSTRUCTED LOGIC!
#

type HtmlElement <
    name <str>
    content <()self>
>

be text = '<b><i>Hello</i>, <u>World</u>!</b>'

fn parseHTML (t <str>) <str> {
    be output <HtmlElement> = (
        name = 'div',
        content = ()
    )

    be latest <@()HtmlElement> = output.content

    # ´<\/?\w+>´
    be tagOpen = ´<\w>´
    be tagClose = ´<\/\w>´

    # if function
    if:s text.startsWith {
        # treats 'is' as the first parameter, where with are return values
        case tagOpen -> v
            latest.push(HtmlElement (
                name = v,
                content = ()
            ))
            latest = latest.last.content
        

        case tagClose -> v
            latest = latest.super
            if latest.super.name != v
                throw: `</$(v)> closes `
        
    } el {
        
    }
}

out: parseHTML(text)

##########################################################################################
#########                     EXAMPLE PACKAGE: THROW MODULE                      #########
##########################################################################################
#
# @throw:s
#

throw {
    fn self(error <str>) {
        out: error
        asm (
            mov eax, 0 # interrupt code
            mov ebx, 0 # argument, in this case: return value
            int b80
        )
    }

    fn dep(error <str>) {
        out: 'Deprecation Warning! ', error
    }
}

#
# index:s
#

use '@lib/throw'

throw: 'Throwing an error'
throw.dep: 'This will only output a deprecation warning!'

##########################################################################################
#########                        CREATING A QUICK OPTION                         #########
##########################################################################################

use '@lib/throw'

type Option(T) <
    <*Some(T)>
    <*Null>
>

Option(T) {
    fn unwrap() <T> {
        if self is Option(value) {
            exit value
        }
        throw: 'Panicked! Trying to unwrap on a null value!'
    }
}

be k = Option.Some('Hello!')
out: k.unwrap()                 # Hello!

##########################################################################################
#########            ADDING DEFAULT ARITHMETIC OPERATIONS TO A CLASS             #########
##########################################################################################