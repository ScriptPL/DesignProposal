
##########################################################################################
#########                              THE BOOLEAN                               #########
##########################################################################################

$[prim 'boolean']
type bool = byte

be true bool = b01
be false bool = b00

##########################################################################################
#########                           THE MODULE FUNCTION                          #########
##########################################################################################

# 20 % 3 => 6
fn mod (a int, b int) int {
    ret a - (a / b) * b
}

fn exp (a num, b num) num {
    # a ^ b
}

out a \mod b

##########################################################################################
#########                               THE OPTION                               #########
##########################################################################################

type Option<Value> (*Some(Value), None)

Option<Value>

# You can leave out the brackets to make it python like "indent based" syntax
# {

    fn unwrap() Value {
        if be Option.Some(value) = self {
            ret value
        }
        throw 'Unwrapped value is None.'

        # or:

        # out 'Panicked! Unwrapped value is None.'
        # ret Value.new()
    }

    fn is_none() bool {
        ret be Option.None = self
    }

    fn is_some() bool {
        ret !self.is_none()
    }

# }

##########################################################################################
#########                               THE RESULT                               #########
##########################################################################################

type Result<V1, V2> (*Ok(V1), *Err(V2))

# k Result(uint, uint)
be k = Result.Ok(200)
k = Result.Err(404)

##########################################################################################
#########                                THE LIST                                #########
##########################################################################################

type RawList<ElT> (
    *Element(ElT, self) |
    *Endpoint
)

$[prim 'list']
type List<ElementType> (
    _list RawList(ElementType)
    _last @RawList(ElementType) = @self._list               # Last -> Endpoint
    _prelast Option(@RawList(ElementType)) = Option.None    # Prelast -> Element or None
    len uint
)

RawList<ElementType> # {

    fn getElementAtPos (pos uint) ElementType {
        be latestChild @List(ElementType) = self
        for i in (begin = 0, end = pos) {
            be (be List.Element = latestChild.1)    # Bypasses the parser checks force-assuming a boolean to be true
            latestChild = latestChild.1             # Index in the array.
        }
        ret latestChild.0
    }

    fn push (element ElementType) {
        self._last = List.Element(element, RawList.Endpoint)
        self._prelast @= self._last
        self._last = self._last.1
    }

    fn<a> pop () {
        if be Option.Some(v) = self._prelast {
            ret 
        }
        ret Option.None

        be latestChild @List(ElementType) = self
        for {
            if be List.Element = latestChild.1 { # while the next child is an element, update the pointer.
                latestChild = latestChild.1
            } el { # if the next child is the endpoint, then make the current node an endpoint
                # latestChild.0 COLLECT GARBAGE?
                self._last = latestChild
                latestChild = RawList.Endpoint
                ret<a>
            }
        }
    }

# }

List<ElT> {

    fn __new () List(ElT) {
        ret List(ElT) {
            _list = RawList(ElT)
            len = 0
        }
    }

    for 'compile time'
    fn __assign (content ()ElT) {
        for i, e in content {
            self.push(e)
        }
    }

    # fn self: SELF.()
    fn self (pos uint) ElT {
        for 'compile time'
        if pos > self.len
            throw "Index out of range!"
        ret self._list.getElementAtPos(pos)
    }

    fn push (element ElT) {
        self._list.push(element)
        ret self.len += 1
    }

    fn pop () {
        if self.len == 0 ret
        self._list.pop
        ret self.len -= 1
    }

    #*fn __plus (value ElT) self {
        self.push(value)
        ret self
    }*#

    fn __assign_plus (values (...) ElT) {
        for _, e in values {
            self.push(values)
        }
    }

    fn combine (list self) {
        # Join the list references
        self._last.1 = list._list
        # Some collection of garbage
    }

}

# Usage:
be k List(uint) = (50, 100, 200)
k.push(50)  # 0
k.push(100) # 1
k += 150    # 2

out k.(1)  # 100

##########################################################################################
#########                               THE STRING                               #########
##########################################################################################

$[prim 'string'] # prim stays for primitive
type str = List(char)

str

    # k self is the same as k str; indicates str + str 
    fn __plus(k self) {
        # Call List methods
        self.combine(k)
    }

##########################################################################################
#########                               THE NUMBER                               #########
##########################################################################################

$[prim 'number']
type num = (byte * 2) # Sort of

num #{

    fn to (conversion T) T {
        # Compile time makes sure that the return type is the same as the input type.
        T(ret) = conversion

        if conversion {
            # type-type comparison
            case str
                # 
        }
    }

#}

##########################################################################################
#########                         ENTITY COMPONENT SYSTEM                        #########
##########################################################################################

ECS {

    be _id uint = 0
    be _map Map(T, Map(uint, _)) = Map()

    fn entity() uint {
        ret _id += 1
    }

    # entity.add(CompType (value))
    fn add(eid uint, comp _) {
        #
        # The following will be executed ONLY during compilation and disappears in runtime.
        #
        for 'compile time' {
            # Compile time make sure that the map object has a proper hierarchy
            _map.(T(comp)) = Map(uint, T(comp))

            # Creates a type function that will be used to add the component to the entity
            T(comp).self = (id uint) T(comp) => {
                ret _map.(T(comp)).(id)
            }

            # Type Logic goes here:
            be (Map(uint, T(comp)) = _map.(T(comp)))
        }

        #
        # The following is compiled to the runtime
        #

        _map.(T(comp)).(eid) = V(comp) # _map.comp_type.eid = comp; V stores the value without type headers.
    }

    fn query(comps (...) T]) func {
        if comps.len == 0 ret fn # () {}

        be entities Set(uint) # Sets are hashmaps without content: You just add keys and remove them
        _map.(comps.shift()).iter((key uint, value _) => entities.add(key))

        # Remove entities from set that don't have one of the component types
        for _, e1 T in comps
            for _, e2 uint in entities
                if !_map.(e1).has(e2)
                    entities.del(e2)

        # Return the entities iterator
        ret entities.iterator
    }

}

# Usage:

be (entity, query, add) = use 'lib/ecs'

type Player
type Position (x int, y int)

be player = entity()

add(player, Player)
add(player, Position (x = 50, y = 50))
add(player, Velocity (x = -1, y = -1))

be iter = query (Player, Position) # iter is a function
for eid uint in iter {
   Position.(eid).x += Velocity.(eid).x
   Position.(eid).y += Velocity.(eid).y
}

# Assets

type Asset(Image)

be e = entity()

add(e, Player)
add(e, Position (x = 50, y = 50))
add(e, Asset(Image(w = 50, h = 50)))

for eid in query (Position, Asset) {
   Asset.(eid).render()
}

##########################################################################################
#########                             RANGE ITERATOR                             #########
##########################################################################################

$[prim 'range']
type Range (
    start num
    end Option(num) = Option.None
    jump num = 1
)

# Range { fn self () {...} }
fn Range.self (i num = self.start) num {
    if be Option.Some(k) = end {
        if k >= self.end {
            ret
        }
    }

    fn next {
        i += self.jump
        if be Option.Some(k) = end {
            if k >= self.end {
                ret
            }
            next
        }
    }
}

for i in Range (start = 1) {
    out i.to(str) # 1, 2, 3, 4, ...
}

##########################################################################################
#########                       WINDOW, DOCUMENT, PROCESS                        #########
##########################################################################################

window {
    fn init () {
        # Initialize the window
        # ...
    }
}

document {
    fn init () {
        # Initialize the window
        # ...
    }
}

process {
    env {
        # Environment variables
        # ...
    }
}