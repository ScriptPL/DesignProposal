
##########################################################################################
#########                               THE OPTION                               #########
##########################################################################################

type Option : Value (*Some(Value), None)

Option(Value) {
    fn unwrap() Value {
        if be Option.Some(value) = self {
            exit value
        }
        throw:p 'Panicked! Unwrapped value is None.'
    }

    fn is_none() bool {
        exit be Option.None = self
    }

    fn is_some() bool {
        exit !self.is_none()
    }
}

##########################################################################################
#########                                THE LIST                                #########
##########################################################################################

$[prim "list"]
type List : ElementType (
    _list RawList(ElementType)
    len uint
)

type RawList : ElT (
    *Element(ElT, self) |
    *Endpoint
)

RawList(ElementType) {
    fn getElementAtPos (pos uint) ElementType {
        be latestChild @List(ElementType) = self
        for i in (begin = 0, end = pos) {
            # Bypasses the parser force-assuming a boolean to be true
            $[trust] be List.Element = latestChild.1
            # Index in the array.
            latestChild = latestChild.1
        }
        exit latestChild.0
    }

    fn<a> push (element ElementType) {
        be latestChild @List(ElementType) = self
        for {
            if be List.Element = latestChild.1 { # while the next child is an element, update the pointer.
                latestChild = latestChild.1
            } el { # if the next child isn't an element, make it one.
                latestChild = RawList.Element(element, RawList.Endpoint)
                exit<a>
            }
        }
    }

    fn<a> pop () ElementType {
        be latestChild @List(ElementType) = self
        for {
            if be List.Element = latestChild.1 { # while the next child is an element, update the pointer.
                latestChild = latestChild.1
            } el { # if the next child is the endpoint, then make the current node an endpoint
                # latestChild.0 COLLECT GARBAGE?
                latestChild = RawList.Endpoint
                exit<a>
            }
        }
    }
}

List(ElT) {
    $[compile time]
    fn $[assign] (content ()ElT) {
        self = (
            len = content.len,
            #_list = [tree ????] ????
        )
    }

    # fn self: SELF.()
    fn self (pos uint) ElT {
        $[compile time] if pos > self.len {
            throw "Index out of range!"
        }
        exit self._list.getElementAtPos(pos)
    }

    fn push (element ElT) {
        self._list.push(element)
        exit self.len += 1
    }

    fn pop () {
        if self.len == 0 exit
        self._list.pop:
        exit self.len -= 1
    }
}

# Usage:
be k List(uint) = ()
k.push(50)  # 0
k.push(100) # 1
k.push(150) # 2

out: k.(1)  # 100

##########################################################################################
#########                               THE STRING                               #########
##########################################################################################

$[prim "string"] # prim stays for primitive
type str = List(char)

str {

}
