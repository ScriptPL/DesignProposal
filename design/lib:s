
##########################################################################################
#########                               THE OPTION                               #########
##########################################################################################

type Option(T) <
    <*Some(T)>
    <*Null>
>

##########################################################################################
#########                               THE ARRAY                                #########
##########################################################################################

use '@lib/throw'

$[prim "list"]
type List(T) <
    _list <RawList(T)>
    len uint
>

type RawList(T) <
    <*Element(0 <T>, 1 <self>)>
    <*Endpoint>
>

RawList(T) {
    fn getElementAtPos (pos <uint>) <T> {
        be latestChild <@List<T>> = self
        for i in (begin = 0, end = pos) {
            if latestChild.1 is List.Element {
                latestChild = latestChild.1
            } el {
                throw: 'Panicked! Index of array out of bounds!'
            }
        }
        exit latestChild.0
    }

    fn:a push (element <T>) <uint> {
        be latestChild <@List<T>> = self
        for {
            if latestChild.1 is List.Element { # while the next child is an element, update the pointer.
                latestChild = latestChild.1
            } el { # if the next child isn't an element, make it one.
                latestChild = RawList.Element(element, RawList.Endpoint)
                exit:a 
            }
        }
    }

    fn:a pop () <T> {
        be latestChild <@List<T>> = self
        for {
            if latestChild.1 is List.Element { # while the next child is an element, update the pointer.
                latestChild = latestChild.1
            } el { # if the next child is the endpoint, then make the current node an endpoint
                # latestChild.0 COLLECT GARBAGE?
                latestChild = RawList.Endpoint
                exit:a 
            }
        }
    }
}

List(T) {
    # fn self: SELF.()
    fn self (pos <uint>) <T> {
        exit self.getElementAtPos(pos)
    }
}

##########################################################################################
#########                               THE STRING                               #########
##########################################################################################

$[prim "string"] # prim stays for primitive
type str <<List(char)>> # one bracket opens the type definition, the one after opens the next type chamber

str {

}
