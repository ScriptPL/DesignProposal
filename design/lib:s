
##########################################################################################
#########                               THE OPTION                               #########
##########################################################################################

type Option : T (*Some(T), Null)

Option<T> {
    fn unwrap() T {
        if be Option.Some(value) = self {
            exit value
        }
        throw:p 'Panicked! Unwrapped value is `Null`'
    }
}

##########################################################################################
#########                               THE ARRAY                                #########
##########################################################################################

$[prim "list"]
type List : T (
    _list RawList(T)
    len uint
)

type RawList : T (
    *Element(T, self) |
    *Endpoint
)

RawList(T) {
    fn getElementAtPos (pos uint) T {
        be latestChild @List<T> = self
        for i in (begin = 0, end = pos) {
            # Bypasses the parser force-assuming a boolean to be true
            $[trust] be List.Element = latestChild.1
            # Index in the array.
            latestChild = latestChild.1
        }
        exit latestChild.0
    }

    fn<a> push (element T) {
        be latestChild @List<T> = self
        for {
            if be List.Element = latestChild.1 { # while the next child is an element, update the pointer.
                latestChild = latestChild.1
            } el { # if the next child isn't an element, make it one.
                latestChild = RawList.Element(element, RawList.Endpoint)
                exit<a>
            }
        }
    }

    fn<a> pop () T {
        be latestChild @List<T> = self
        for {
            if be List.Element = latestChild.1 { # while the next child is an element, update the pointer.
                latestChild = latestChild.1
            } el { # if the next child is the endpoint, then make the current node an endpoint
                # latestChild.0 COLLECT GARBAGE?
                latestChild = RawList.Endpoint
                exit<a>
            }
        }
    }
}

List(T) {
    $['compile time']
    fn $[assign] (content ()T) {
        self = (
            len = content.len,
            #_list = [tree ????] ????
        )
    }

    # fn self: SELF.()
    fn self (pos <uint>) <T> {
        $['compile time'] if pos > self.len {
            throw "Index out of range!"
        }
        exit self._list.getElementAtPos(pos)
    }

    fn push (element <T>) {
        self._list.push(element)
        exit self.len += 1
    }

    fn pop () {
        if self.len == 0 exit
        self._list.pop:
        exit self.len -= 1
    }
}

# Usage:
be k List<uint> = ()
k.push(50)  # 0
k.push(100) # 1
k.push(150) # 2

out: k.(1)  # 100

##########################################################################################
#########                               THE STRING                               #########
##########################################################################################

$[prim "string"] # prim stays for primitive
type str = List(char)

str {

}
