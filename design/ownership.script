
##########################################################################################
#########                           VARIABLE LIFETIMES                           #########
##########################################################################################

# Lifetimes of variables

{
    be k = 0
    # lifetime of k starts here
    # z is not yet declared
    {
        be z = 0
        # lifetime of z starts here
        #
        # z becomes invalid
    }
    #
    # k becomes invalid
}

##########################################################################################
#########                         RUST INSPIRED OWNERSHIP                        #########
##########################################################################################

own # pass by ownership. variable is moved out of scope.
cut # pass by mutable reference, variable is borrowed out of scope but will return at the end.
new # pass by copy, variable is cloned.

######################################## OWNERSHIP #######################################

fn takeVariable(own k str) {
    # k is owned
}

be j = 'Hello!'
takeVariable(j)
# j is invalid

############################# PASS BY MUTABLE REFERENCE = CUT ############################

fn cutValue (cut v uint) {
    # Think of it like cntrl + x: cut the value into this scope, then paste it back.
    # In rust, it's a &mut reference, you cannot inherit two mutable references.

    # You cannot use 'takeVariable(k)' here since it requires ownership.
}

be k = 0
# k is valid
cutValue(k)
# k is valid
takeVariable(k)
# k is invalid

###################################### PASS BY COPY ######################################

fn copyValue (new v uint) {
    # v is cloned
    # v is the owner of the variable, you can pass it by ownership
}

be k = 0
copyValue(k)
# k is valid

############################### GARBAGE COLLECTION / TRACE ###############################

fn traceValue (v uint) {
    # +1 to v references count. (traces per default unless compiler is smart enough)
    # v is considered one of mutable references here.
    # -1 to v references count.
}

##########################################################################################
#########                                 PARSER                                 #########
##########################################################################################

type Token (
    uint
    | *Plus
    | *Minus
)

be string = '1230 + 234 - 239 + 439 - 2349 - 23423'

fn parse(cut s str) Stack<Token> {
    be tokens = Stack<Token>()

    # for all characters
    # switch at every character
    for c char in s if s.match
        case ´\s´

        case ´\+´
            tokens.push(Plus)

        case ´\-´
            tokens.push(Minus)

        case ´[0-9]´
            tokens.push(parse_number(s + c))

}

fn parse_number(cut s str) uint {
    be buffer String

    # for all characters
    # switch at every character
    for<l> c char in s
        if s.match(´[0-9]´)
            buffer += c
        el ret<l>
        
    s += c

    buffer.to(uint)
}

be tokens = parse(string)



##########################################################################################
#########                                CLOSURES                                #########
##########################################################################################
#
# Closures are functions that can access variables from the scope they were defined in.
#

-> own # access by ownership.
-> cut # access by mutable reference.
-> new # access by copy, variable is cloned upon closure creation
-> # access by mutable copy, garbage collected OR

# To indicate a variable to be captured into the function, write an arrow '->'
# Leaving the arrow will - same with leaving the pass kinds of the ownership system - 
# make the variable be traced by references.

# In here it's just indicating that it's getting captured, but it's not any sort of special
# reference. This will have the same effect, but makes things readable.
be i = 0

fn tab(-> i) {
    ret ' '.rep(i)
    
    # i is taken from environment as a reference
    # -> function CAN NOT outlive variable
}

for t in ('a', 'indent', 'b', 'c', 'indent', 'd', 'outdent', 'e', 'outdent', 'f') {
    if t {
        case 'indent'
            i += 1

        case 'outdent'
            i -= 1
    } el {
        out(tab(), t)
    }
}